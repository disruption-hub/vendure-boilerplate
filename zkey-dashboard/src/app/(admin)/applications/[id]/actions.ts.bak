"use server";

import { prisma } from "@/lib/prisma";
import * as crypto from "node:crypto";

function processFormDataUrls(formData: FormData, key: string): string[] {
    const raw = formData.getAll(key);
    // If only one entry, it might be comma separated (from simple forms)
    if (raw.length === 1 && (raw[0] as string).includes(',')) {
        return (raw[0] as string).split(',').map(s => s.trim()).filter(Boolean);
    }
    // Otherwise return all separate entries (from dynamic forms)
    return raw.map(s => (s as string).trim()).filter(Boolean);
}

export async function updateApplication(id: string, formData: FormData) {
    const name = formData.get("name") as string;
    const tenantId = formData.get("tenantId") as string;

    const corsOrigins = processFormDataUrls(formData, "corsOrigins");
    const redirectUris = processFormDataUrls(formData, "redirectUris");
    const postLogoutRedirectUris = processFormDataUrls(formData, "postLogoutRedirectUris");

    if (!name || !tenantId) {
        throw new Error("Name and Tenant are required");
    }

    // Extract auth methods
    const authMethods = {
        password: formData.get("auth_password") === "on",
        otp: formData.get("auth_otp") === "on",
        wallet: formData.get("auth_wallet") === "on",
    };

    // Custom Data handling
    let customData = {};
    try {
        const customDataStr = formData.get("customData") as string;
        if (customDataStr) {
            customData = JSON.parse(customDataStr);
        }
    } catch (e) {
        console.error("Failed to parse custom data JSON", e);
    }

    try {
        await prisma.application.update({
            where: { id },
            data: {
                name,
                description: formData.get("description") as string || null,
                tenantId,
                corsOrigins,
                redirectUris,
                postLogoutRedirectUris,
                authMethods,

                // Branding
                logo: formData.get("logo") as string || null,
                primaryColor: formData.get("primaryColor") as string || null,
                branding: {
                    logo: formData.get("logo") as string || null,
                    primaryColor: formData.get("primaryColor") as string || null,
                    backgroundColor: formData.get("backgroundColor") as string || null,
                    loginTitle: formData.get("loginTitle") as string || null,
                    loginSubtitle: formData.get("loginSubtitle") as string || null,
                },

                // Refresh Token
                alwaysIssueRefreshToken: formData.get("alwaysIssueRefreshToken") === "on",
                rotateRefreshToken: formData.get("rotateRefreshToken") === "on",
                refreshTokenTtl: parseInt(formData.get("refreshTokenTtl") as string) || 14,

                // Logout
                backchannelLogoutUri: formData.get("backchannelLogoutUri") as string || null,
                isSessionRequired: formData.get("isSessionRequired") === "on",

                // Custom Data
                customData,

                integrations: {
                    brevoApiKey: formData.get("brevoApiKey") as string || null,
                    brevoSenderEmail: formData.get("brevoSenderEmail") as string || null,
                    brevoSenderName: formData.get("brevoSenderName") as string || null,
                    labsmobileApiKey: formData.get("labsmobileApiKey") as string || null,
                    labsmobileUser: formData.get("labsmobileUser") as string || null,
                    labsmobileUrl: formData.get("labsmobileUrl") as string || null,
                    labsmobileSenderId: formData.get("labsmobileSenderId") as string || null,
                },
            },
        });
    } catch (error) {
        throw new Error(`Failed to update application: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
}

export async function createApplication(formData: FormData) {
    const name = formData.get("name") as string;
    const tenantId = formData.get("tenantId") as string;

    const corsOrigins = processFormDataUrls(formData, "corsOrigins");
    const redirectUris = processFormDataUrls(formData, "redirectUris");
    const postLogoutRedirectUris = processFormDataUrls(formData, "postLogoutRedirectUris");

    if (!name || !tenantId) {
        throw new Error("Name and Tenant are required");
    }

    try {
        const application = await prisma.application.create({
            data: {
                name,
                description: formData.get("description") as string || null,
                tenantId,
                clientId: crypto.randomUUID(),
                clientSecret: crypto.randomBytes(32).toString('hex'),
                corsOrigins,
                redirectUris,
                postLogoutRedirectUris,
                authMethods: { password: true, otp: false, wallet: false },

                // Branding
                logo: formData.get("logo") as string || null,
                primaryColor: formData.get("primaryColor") as string || null,
                branding: {
                    logo: formData.get("logo") as string || null,
                    primaryColor: formData.get("primaryColor") as string || null,
                    backgroundColor: formData.get("backgroundColor") as string || null,
                    loginTitle: formData.get("loginTitle") as string || null,
                    loginSubtitle: formData.get("loginSubtitle") as string || null,
                },

                // Refresh Token
                alwaysIssueRefreshToken: formData.get("alwaysIssueRefreshToken") === "on",
                rotateRefreshToken: formData.get("rotateRefreshToken") === "on",
                refreshTokenTtl: parseInt(formData.get("refreshTokenTtl") as string) || 14,

                // Logout
                backchannelLogoutUri: formData.get("backchannelLogoutUri") as string || null,
                isSessionRequired: formData.get("isSessionRequired") === "on",

                integrations: {
                    brevoApiKey: formData.get("brevoApiKey") as string || null,
                    brevoSenderEmail: formData.get("brevoSenderEmail") as string || null,
                    brevoSenderName: formData.get("brevoSenderName") as string || null,
                    labsmobileApiKey: formData.get("labsmobileApiKey") as string || null,
                    labsmobileUser: formData.get("labsmobileUser") as string || null,
                    labsmobileUrl: formData.get("labsmobileUrl") as string || null,
                    labsmobileSenderId: formData.get("labsmobileSenderId") as string || null,
                },
            },
        });
        return application;
    } catch (error) {
        throw new Error(`Failed to create application: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
}

export async function regenerateClientSecret(id: string) {
    const newSecret = crypto.randomBytes(32).toString('hex');
    try {
        await prisma.application.update({
            where: { id },
            data: { clientSecret: newSecret }
        });
        return { success: true, secret: newSecret };
    } catch (error) {
        throw new Error("Failed to regenerate secret");
    }
}

export async function deleteApplication(id: string) {
    try {
        await prisma.application.delete({
            where: { id },
        });
    } catch (error) {
        throw new Error(`Failed to delete application: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
}
