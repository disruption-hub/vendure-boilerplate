import { existsSync, readFileSync } from 'node:fs'
import { basename } from 'node:path'
import { Injectable, OnModuleDestroy, OnModuleInit } from '@nestjs/common'
import { ConfigService } from '@nestjs/config'
// Use @prisma/client from node_modules (generated by prisma-client-js provider)
// This is CommonJS-compatible and works with ts-node
import { PrismaClient } from '@prisma/client'
import { PrismaPg } from '@prisma/adapter-pg'
import { Pool } from 'pg'

const FALLBACK_VARIABLES = [
  'DATABASE_DIRECT_URL',
  'DATABASE_PUBLIC_URL',
  'DATABASE_URL_NON_POOLING',
  'DATABASE_URL_UNPOOLED',
  'DATABASE_URL_WITH_SSL',
  'DATABASE_URI',
  'DATABASE_CONNECTION_URL',
  'DATABASE_DEFAULT_URL',
  'POSTGRES_URL',
  'POSTGRES_URL_NON_POOLING',
  'POSTGRES_PRISMA_URL',
  'POSTGRES_DATABASE_URL',
  'POSTGRESQL_URL',
  'POSTGRESQL_URL_NON_POOLING',
  'POSTGRES_CONNECTION_STRING',
  'NEON_DATABASE_URL',
  'SUPABASE_DB_URL',
  'RAILWAY_DATABASE_URL',
  'PRISMA_DATABASE_URL',
  'SUPABASE_POSTGRES_URL',
  'SUPABASE_PG_URL',
  'DB_CONNECTION_URL',
  'DB_URL',
  'SHADOW_DATABASE_URL',
]

const FILE_VARIABLES = ['DATABASE_URL_FILE', 'DATABASE_URL_PATH', 'DATABASE_FILE', 'DATABASE_CONNECTION_FILE']

const HOST_VARIABLES = [
  'PGHOST',
  'PGHOSTADDR',
  'POSTGRES_HOST',
  'POSTGRESQL_HOST',
  'DATABASE_HOST',
  'DB_HOST',
  'DBHOST',
]
const USER_VARIABLES = [
  'PGUSER',
  'POSTGRES_USER',
  'POSTGRESQL_USER',
  'DATABASE_USER',
  'DB_USER',
  'DBUSER',
]
const PASSWORD_VARIABLES = [
  'PGPASSWORD',
  'PGPASSWORD_FILE',
  'POSTGRES_PASSWORD',
  'POSTGRES_PASSWORD_FILE',
  'POSTGRESQL_PASSWORD',
  'POSTGRESQL_PASSWORD_FILE',
  'DATABASE_PASSWORD',
  'DB_PASSWORD',
  'DB_PASSWORD_FILE',
  'DBPASS',
]
const DATABASE_NAME_VARIABLES = [
  'PGDATABASE',
  'POSTGRES_DB',
  'POSTGRESQL_DATABASE',
  'DATABASE_NAME',
  'DB_NAME',
  'DBNAME',
]
const PORT_VARIABLES = ['PGPORT', 'POSTGRES_PORT', 'POSTGRESQL_PORT', 'DATABASE_PORT', 'DB_PORT', 'DBPORT']
const SSL_REQUIRE_VARIABLES = ['PGSSLMODE', 'POSTGRES_SSLMODE', 'DATABASE_SSL_MODE']

function isRailwayEnvironment(): boolean {
  return Boolean(process.env.RAILWAY_ENVIRONMENT || process.env.RAILWAY_PROJECT_ID || process.env.RAILWAY_STATIC_URL)
}

function isLikelyRemoteEnvironment(): boolean {
  if (isRailwayEnvironment()) {
    return true
  }

  const nodeEnv = process.env.NODE_ENV?.toLowerCase()
  if (nodeEnv && nodeEnv !== 'development' && nodeEnv !== 'test') {
    return true
  }

  return Boolean(process.env.CI || process.env.VERCEL || process.env.RENDER)
}

function isLocalHostname(hostname: string): boolean {
  const lowered = hostname.toLowerCase()
  return [
    'localhost',
    '127.0.0.1',
    '::1',
    '0.0.0.0',
  ].some((candidate) => lowered === candidate) || lowered.endsWith('.local')
}

function shouldIgnoreLocalUrl(candidate: string): boolean {
  try {
    const parsed = new URL(candidate)
    return isLikelyRemoteEnvironment() && isLocalHostname(parsed.hostname)
  } catch (error) {
    return false
  }
}

function resolveEnvValue(keys: string[]): { key: string; value: string } | undefined {
  for (const key of keys) {
    const raw = process.env[key]
    if (typeof raw === 'string' && raw.trim()) {
      return { key, value: raw.trim() }
    }
  }
  return undefined
}

function resolveEnvContains(search: string, { exclude = [] }: { exclude?: string[] } = {}): {
  key: string
  value: string
} | undefined {
  const loweredSearch = search.toLowerCase()
  for (const [key, raw] of Object.entries(process.env)) {
    if (typeof raw !== 'string') {
      continue
    }

    const loweredKey = key.toLowerCase()

    if (!loweredKey.includes(loweredSearch)) {
      continue
    }

    if (exclude.some((item) => loweredKey.includes(item.toLowerCase()))) {
      continue
    }

    const value = raw.trim()
    if (value) {
      return { key, value }
    }
  }

  return undefined
}

function readEnvFile(keys: string[]): { key: string; value: string } | undefined {
  for (const key of keys) {
    const candidate = process.env[key]?.trim()
    if (!candidate) {
      continue
    }

    const filePath = candidate.startsWith('~/') ? candidate.replace('~', process.env.HOME ?? '') : candidate

    if (!existsSync(filePath)) {
      continue
    }

    const fileValue = readFileSync(filePath, 'utf8').trim()
    if (fileValue) {
      return { key, value: fileValue }
    }
  }
  return undefined
}

function maskUrl(url: string): string {
  try {
    const parsed = new URL(url)
    if (parsed.password) {
      parsed.password = '***'
    }
    return parsed.toString()
  } catch (error) {
    return `${basename(url)} (non-url)`
  }
}

function ensureDatabaseUrl(configService?: ConfigService): string | undefined {
  // Diagnostic logging for Railway
  if (isRailwayEnvironment()) {
    console.info('ğŸ” Railway environment detected - checking for database connection...')
    const railwayDbVars = Object.keys(process.env)
      .filter((key) => key.toUpperCase().includes('DATABASE') || key.toUpperCase().includes('POSTGRES'))
      .map((key) => `${key}=${process.env[key]?.substring(0, 30)}...`)
    if (railwayDbVars.length > 0) {
      console.info(`ğŸ“‹ Found database-related environment variables: ${railwayDbVars.join(', ')}`)
    } else {
      console.warn('âš ï¸  No database-related environment variables found. Railway should provide DATABASE_URL when database service is connected.')
    }
  }

  // On Railway, DATABASE_URL should be provided directly by Railway when database is connected
  // Check environment DATABASE_URL first (Railway provides this)
  const existing = resolveEnvValue(['DATABASE_URL'])
  if (existing) {
    if (shouldIgnoreLocalUrl(existing.value)) {
      console.warn(
        `DATABASE_URL from ${existing.key} points to localhost (${maskUrl(existing.value)}); ignoring for remote deployment.`,
      )
      if (isRailwayEnvironment()) {
        console.error(
          'âŒ Railway detected a localhost DATABASE_URL. This usually means:\n' +
            '   1. A localhost DATABASE_URL is manually set in Railway environment variables\n' +
            '   2. No PostgreSQL database service is connected to your Railway project\n' +
            '   3. The database service is not linked to your backend service\n\n' +
            '   SOLUTION: In Railway dashboard:\n' +
            '   1. Go to your backend service â†’ Variables tab\n' +
            '   2. DELETE the localhost DATABASE_URL variable (if it exists)\n' +
            '   3. Add a PostgreSQL database service:\n' +
            '      - Click "+ New" â†’ "Database" â†’ "Add PostgreSQL"\n' +
            '   4. Link the database to your backend service:\n' +
            '      - Railway will auto-provide DATABASE_URL from the database service\n' +
            '      - Or click "Add Reference" and select your PostgreSQL service',
        )
      }
    } else {
      console.info(`DATABASE_URL already defined via ${existing.key}`)
      process.env.DATABASE_URL = existing.value
      return existing.value
    }
  }

  // Then check ConfigService (but prioritize env vars on Railway)
  const configValue = configService?.get<string>('DATABASE_URL')?.trim()
  if (configValue) {
    if (shouldIgnoreLocalUrl(configValue)) {
      console.warn(
        `ConfigService provided local DATABASE_URL (${maskUrl(configValue)}); ignoring because deployment appears remote.`,
      )
    } else {
      process.env.DATABASE_URL = configValue
      console.info(`DATABASE_URL resolved via ConfigService (${maskUrl(configValue)})`)
      return configValue
    }
  }

  const fileValue = readEnvFile(FILE_VARIABLES)
  if (fileValue) {
    if (shouldIgnoreLocalUrl(fileValue.value)) {
      console.warn(
        `DATABASE_URL from ${fileValue.key} points to localhost (${maskUrl(fileValue.value)}); ignoring for remote deployment.`,
      )
    } else {
      process.env.DATABASE_URL = fileValue.value
      console.info(`DATABASE_URL resolved from ${fileValue.key} (${maskUrl(fileValue.value)})`)
      return fileValue.value
    }
  }

  const fallback = resolveEnvValue(FALLBACK_VARIABLES)
  if (fallback) {
    if (shouldIgnoreLocalUrl(fallback.value)) {
      console.warn(
        `DATABASE_URL from ${fallback.key} points to localhost (${maskUrl(fallback.value)}); ignoring for remote deployment.`,
      )
    } else {
      process.env.DATABASE_URL = fallback.value
      console.info(`DATABASE_URL resolved from ${fallback.key} (${maskUrl(fallback.value)})`)
      return fallback.value
    }
  }

  const fuzzyUrl = resolveEnvContains('DATABASE_URL', { exclude: ['file'] })
  if (fuzzyUrl) {
    if (shouldIgnoreLocalUrl(fuzzyUrl.value)) {
      console.warn(
        `DATABASE_URL from fuzzy match ${fuzzyUrl.key} points to localhost (${maskUrl(fuzzyUrl.value)}); ignoring for remote deployment.`,
      )
    } else {
      process.env.DATABASE_URL = fuzzyUrl.value
      console.info(`DATABASE_URL resolved from fuzzy match ${fuzzyUrl.key} (${maskUrl(fuzzyUrl.value)})`)
      return fuzzyUrl.value
    }
  }

  const hostEntry = resolveEnvValue(HOST_VARIABLES)
  const databaseEntry = resolveEnvValue(DATABASE_NAME_VARIABLES)

  if (!hostEntry || !databaseEntry) {
    const fallbackHost = resolveEnvContains('host', { exclude: ['hostname'] })
    if (!hostEntry && fallbackHost) {
      // Only use host if it's not a container hostname (Railway uses container hostnames)
      const hostValue = fallbackHost.value.toLowerCase()
      if (!hostValue.includes('railway') && !isLocalHostname(hostValue)) {
        process.env.PGHOST = fallbackHost.value
        console.info(`PGHOST synthesized from ${fallbackHost.key}`)
      }
    }

    const fallbackDatabase = resolveEnvContains('database', { exclude: ['url'] })
    if (!databaseEntry && fallbackDatabase) {
      // Don't use DATABASE_URL as database name - it's a full connection string
      const dbValue = fallbackDatabase.value
      if (!dbValue.includes('://') && !dbValue.includes('@')) {
        process.env.PGDATABASE = fallbackDatabase.value
        console.info(`PGDATABASE synthesized from ${fallbackDatabase.key}`)
      }
    }
  }

  const effectiveHostEntry = hostEntry ?? resolveEnvValue(['PGHOST', 'PGHOSTADDR'])
  const effectiveDatabaseEntry = databaseEntry ?? resolveEnvValue(['PGDATABASE'])

  if (effectiveHostEntry && effectiveDatabaseEntry) {
    // Validate that we're not using a container hostname or invalid database name
    const hostValue = effectiveHostEntry.value.toLowerCase()
    const dbValue = effectiveDatabaseEntry.value

    // Don't construct URL if host is a container hostname (Railway container IDs are hex strings)
    if (hostValue.match(/^[a-f0-9]{12}$/)) {
      console.warn(
        `Cannot construct DATABASE_URL: PGHOST appears to be a container hostname (${effectiveHostEntry.value}). Railway should provide DATABASE_URL directly when database service is connected.`,
      )
      return undefined
    }

    // Don't construct URL if database name looks like a connection string
    if (dbValue.includes('://') || dbValue.includes('@')) {
      console.warn(
        `Cannot construct DATABASE_URL: PGDATABASE appears to be a connection string (${dbValue.substring(0, 50)}...). Please set DATABASE_URL directly in Railway.`,
      )
      return undefined
    }

    const userEntry = resolveEnvValue(USER_VARIABLES) ?? { key: 'default_user', value: 'postgres' }
    const passwordEntry = resolveEnvValue(PASSWORD_VARIABLES)
    const portEntry = resolveEnvValue(PORT_VARIABLES)
    const sslEntry = resolveEnvValue(SSL_REQUIRE_VARIABLES)

    let password = passwordEntry?.value ?? ''
    if (passwordEntry?.key.endsWith('_FILE')) {
      try {
        if (existsSync(password)) {
          const pwdFromFile = readFileSync(password, 'utf8').trim()
          if (pwdFromFile) {
            password = pwdFromFile
          }
        }
      } catch (error) {
        console.warn(`Failed to read password from ${passwordEntry.key}: ${(error as Error).message}`)
        password = ''
      }
    }
    const port = portEntry?.value ?? '5432'
    const sslMode = sslEntry?.value?.toLowerCase()

    const authSegment = password
      ? `${encodeURIComponent(userEntry.value)}:${encodeURIComponent(password)}`
      : encodeURIComponent(userEntry.value)

    const encodedDb = encodeURIComponent(effectiveDatabaseEntry.value)
    const sslSuffix = sslMode && sslMode !== 'disable' ? '?sslmode=require' : ''

    const connectionUrl = `postgresql://${authSegment}@${effectiveHostEntry.value}:${port}/${encodedDb}${sslSuffix}`
    if (shouldIgnoreLocalUrl(connectionUrl)) {
      console.warn(
        `DATABASE_URL constructed from component variables still points to localhost (${maskUrl(connectionUrl)}); ignoring for remote deployment.`,
      )
      return undefined
    } else {
      process.env.DATABASE_URL = connectionUrl
      const sourceKeys = [
        userEntry.key === 'default_user' ? undefined : userEntry.key,
        passwordEntry?.key,
        effectiveHostEntry.key,
        portEntry?.key,
        effectiveDatabaseEntry.key,
      ]
        .filter(Boolean)
        .join(', ')

      console.info(`DATABASE_URL constructed from component variables (${sourceKeys}) -> ${maskUrl(connectionUrl)}`)
      return connectionUrl
    }
  }

  console.warn('DATABASE_URL is not defined; Prisma will attempt local connection settings.')
  if (isRailwayEnvironment()) {
    console.error(
      '\n' +
        'â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n' +
        'âŒ DATABASE_URL is required on Railway but not found!\n' +
        'â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n' +
        'To fix this, you need to connect a PostgreSQL database to your Railway project:\n\n' +
        '1. Go to your Railway project dashboard\n' +
        '2. Click "+ New" â†’ "Database" â†’ "Add PostgreSQL"\n' +
        '3. Railway will automatically create a database service\n' +
        '4. Link the database to your backend service:\n' +
        '   - Click on your backend service\n' +
        '   - Go to "Variables" tab\n' +
        '   - Railway should auto-provide DATABASE_URL from the database service\n' +
        '   - If not, click "Add Reference" and select your PostgreSQL service\n\n' +
        'Alternatively, you can manually set DATABASE_URL:\n' +
        '1. Go to your backend service â†’ Variables\n' +
        '2. Add variable: DATABASE_URL\n' +
        '3. Set value to your PostgreSQL connection string\n' +
        '   Format: postgresql://user:password@host:port/database\n\n' +
        'â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n',
    )
  }
  return undefined
}

function resolveDatabaseUrl(configService?: ConfigService): string {
  const value = ensureDatabaseUrl(configService)

  if (!value) {
    throw new Error(
      'DATABASE_URL is required but not found. Please configure a database connection string in environment variables or ConfigService.',
    )
  }

  return value
}

@Injectable()
export class PrismaService extends PrismaClient implements OnModuleInit, OnModuleDestroy {
  private _isReady = false

  get isReady(): boolean {
    return this._isReady
  }

  constructor(private readonly configService: ConfigService) {
    const databaseUrl = resolveDatabaseUrl(configService)

    // Create a connection pool for the adapter
    const pool = new Pool({
      connectionString: databaseUrl,
    })

    // Create the Prisma adapter
    const adapter = new PrismaPg(pool)

    // Initialize PrismaClient with the adapter
    // @prisma/client from prisma-client-js is CommonJS-compatible
    super({ adapter })

    // Force model initialization by accessing them
    // This ensures models are available when services need them
    this.forceModelInitialization()
  }

  private forceModelInitialization() {
    try {
      // Access models to trigger initialization
      const models = [
        'tenant',
        'chatbotPhoneUser',
        'chatbotPhoneOtp',
        'paymentProduct',
        'paymentLink',
        'stockEntry',
        'stockLocation',
        'user',
      ]

      for (const modelName of models) {
        if (this[modelName]) {
          // Access the model to ensure it's initialized
          const model = this[modelName]
          console.log(`[PrismaService] Model ${modelName} initialized: ${typeof model}`)
        } else {
          console.warn(`[PrismaService] Model ${modelName} not found on PrismaClient`)
        }
      }
    } catch (error) {
      console.error('[PrismaService] Error during model initialization:', error)
    }
  }

  async onModuleInit(): Promise<void> {
    try {
      await this.$connect()
      // Verify basic database connectivity
      await this.$queryRaw`SELECT 1`

      // Verify all critical models are available and accessible
      const modelsToCheck = ['tenant', 'chatbotPhoneUser', 'chatbotPhoneOtp', 'paymentProduct']
      for (const modelName of modelsToCheck) {
        if (!this[modelName] || typeof this[modelName].count !== 'function') {
          throw new Error(`Prisma model ${modelName} is not accessible`)
        }
        // Test the model by calling count
        await this[modelName].count()
        console.log(`[PrismaService] âœ… Model ${modelName} is accessible`)
      }

      this._isReady = true
      console.log('[PrismaService] âœ… Successfully connected to database and all models are ready')
    } catch (error) {
      console.error('[PrismaService] âŒ Failed to connect to database or initialize models:', error)
      throw error
    }
  }

  async onModuleDestroy(): Promise<void> {
    await this.$disconnect()
  }
}
